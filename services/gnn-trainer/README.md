Роль: Ты — эксперт в области количественных финансов и машинного обучения, специализирующийся на Python, PyTorch Geometric (PyG) и работе с API криптовалютных бирж.

Задача: Разработать и написать код для GNN-модели, которая анализирует состояние крипторынка на основе данных от Binance и прогнозирует краткосрочное движение цен. Конечная цель — создать компонент, который можно будет интегрировать в более крупную торговую систему (например, в RL-агента в качестве источника признаков).

I. Сбор данных с Binance

Тебе нужно будет получать следующие данные через официальный API Binance (или python-binance):

Список всех торговых пар к USDT: Нам нужен полный список активов для построения узлов графа (например, BTCUSDT, ETHUSDT, SOLUSDT и т.д.). Отфильтруй низколиквидные пары (например, по суточному объему торгов).
Исторические данные K-lines (свечи):
Таймфрейм: 1 час (1h).
Данные: Open, High, Low, Close, Volume (OHLCV).
Глубина истории: не менее 200 последних свечей для каждого актива для расчета признаков и корреляций.
Данные стакана (Order Book Depth):
Для каждого актива получать топ-20 уровней бидов (цен на покупку) и асков (цен на продажу).
Ставка финансирования (Funding Rate):
Для бессрочных фьючерсов (Perpetual Futures). Это ключевой индикатор настроений на рынке.
II. Построение динамического графа (Graph Construction)

На каждом временном шаге (каждый час) необходимо строить новый граф рынка.

Узлы (Nodes):

Каждая торговая пара (например, BTCUSDT) является узлом графа.
Признаки узлов (Node Features):

Для каждого узла нужно рассчитать вектор признаков на основе данных, полученных в шаге I. Включи в него:
Ценовые признаки:
Логарифмическая доходность за последние 1, 4, 12, 24 часа.
Волатильность (стандартное отклонение доходности) за последние 24 часа.
RSI (индекс относительной силы) с периодом 14.
Объемные признаки:
Отношение объема последней свечи к среднему объему за 24 часа.
Признаки из стакана:
Спред (разница между лучшим аском и лучшим бидом).
Дисбаланс стакана (отношение суммарного объема на покупку к суммарному объему на продажу в топ-20 уровнях).
Признаки из фьючерсов:
Текущая ставка финансирования.
Ребра (Edges) и их веса:

Ребра должны отражать взаимосвязь между активами.
Создай полносвязный граф, где ребро между двумя узлами (активами) имеет вес, равный корреляции Пирсона их логарифмических доходностей за последние 100 часов.
Ребра должны быть динамическими и пересчитываться на каждом шаге.
III. Архитектура GNN-модели

Используй PyTorch и PyTorch Geometric (PyG).

Тип модели: Модель для классификации узлов графа (Node Classification).
Вход: Data объект из PyG, содержащий:
x: матрица признаков узлов ([num_nodes, num_node_features]).
edge_index: матрица связности графа.
edge_attr: вектор весов ребер (корреляции).
Слои:
Используй 2-3 слоя Graph Attention Convolution (GATv2Conv). Этот слой позволит модели самой определять важность связей между активами, что идеально для финансовых рынков.
Между слоями используй активацию ReLU и слой нормализации, например, GraphNorm.
Выход:
Модель должна предсказывать класс движения цены для каждого актива на следующий час.
Целевая переменная (Target):
Класс 1 (UP): если цена вырастет более чем на 1%.
Класс -1 (DOWN): если цена упадет более чем на 1%.
Класс 0 (SIDEWAYS): в остальных случаях.
Выходной слой — Linear с 3 нейронами (по числу классов) и LogSoftmax.
IV. План реализации

Предоставь код, разделенный на следующие логические модули:

binance_client.py: Класс для инкапсуляции логики запросов к API Binance для получения всех необходимых данных.
feature_generator.py: Функции для расчета признаков узлов и весов ребер (корреляций) на основе сырых данных.
graph_builder.py: Класс или функция, которая принимает данные от binance_client и feature_generator и создает Data объект PyG для одного временного среза.
model.py: Определение класса GNN-модели на PyTorch Geometric (torch.nn.Module).
train.py: Основной скрипт, который:
Организует цикл обучения.
На каждом шаге генерирует новый граф.
Обучает модель, используя NLLLoss (Negative Log Likelihood Loss) и оптимизатор Adam.
Включает базовую логику для оценки модели (accuracy, F1-score).
V. Итог

В результате я хочу получить:

Полный, готовый к запуску Python-код, структурированный по указанным выше файлам.
Файл requirements.txt со всеми необходимыми библиотеками (torch, torch_geometric, pandas, numpy, python-binance).
Краткое объяснение в комментариях к коду ключевых моментов, особенно в части построения графа и архитектуры модели.